/**
 * Document OCR Processor Interface
 * 
 * Production-grade document processing interface with advanced OCR capabilities,
 * computer vision analysis, and real-time extraction results. Supports multiple
 * document formats with confidence scoring and structured data extraction.
 * 
 * Features:
 * - Multi-format document support (PDF, images, scanned documents)
 * - Real-time OCR processing with progress tracking
 * - Computer vision analysis and confidence scoring
 * - Structured data extraction and validation
 * - Document type auto-detection and classification
 * - Batch processing capabilities
 * - Export and sharing functionality
 * - Integration with mortgage application workflow
 * - Accessibility compliance and responsive design
 * - Advanced error handling and retry mechanisms
 */

import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import {
  Container,
  Card,
  Group,
  Stack,
  Text,
  Button,
  Progress,
  Badge,
  Alert,
  Modal,
  Tabs,
  Table,
  ScrollArea,
  ActionIcon,
  Tooltip,
  Menu,
  Divider,
  Paper,
  ThemeIcon,
  Grid,
  Select,
  Switch,
  Textarea,
  JsonInput,
  Code,
  Anchor,
  Timeline,
  Spotlight,
  Loader,
  FileInput,
  Image,
  Notification,
  RingProgress,
  SimpleGrid,
  Accordion,
  List,
  Checkbox,
  NumberInput,
  Slider
} from '@mantine/core';
import {
  IconUpload,
  IconFile,
  IconFileText,
  IconPhoto,
  IconScan,
  IconEye,
  IconDownload,
  IconShare,
  IconTrash,
  IconRefresh,
  IconCheck,
  IconX,
  IconAlertTriangle,
  IconClock,
  IconBrain,
  IconRobot,
  IconShield,
  IconChartBar,
  IconSettings,
  IconZoomIn,
  IconZoomOut,
  IconRotate,
  IconCrop,
  IconAdjustments,
  IconMagnet,
  IconSearch,
  IconFilter,
  IconArrowsSort,
  IconExternalLink,
  IconCopy,
  IconEdit,
  IconDeviceFloppy,
  IconDatabase,
  IconCloudUpload,
  IconDeviceDesktop,
  IconDeviceMobile,
  IconDeviceTablet,
  IconPrinter,
  IconMail,
  IconBrandWhatsapp,
  IconBrandTelegram,
  IconFileExport,
  IconFileImport,
  IconHistory,
  IconBookmark,
  IconTag,
  IconFolder,
  IconFolderOpen,
  IconArchive,
  IconLock,
  IconLockOpen,
  IconKey,
  IconFingerprint,
  IconQrcode,
  IconBarcode,
  IconCertificate,
  IconAward,
  IconTarget,
  IconFocus,
  IconZoom
} from '@tabler/icons-react';
import { useNavigate } from 'react-router-dom';
import { notifications } from '@mantine/notifications';
import { modals } from '@mantine/modals';
import { spotlight } from '@mantine/spotlight';
import { useDemoMode } from '../contexts/DemoModeContext';
import { useClient } from '../contexts/ClientContext';
import { useDisclosure, useLocalStorage, useViewportSize } from '@mantine/hooks';

// TypeScript interfaces for comprehensive type safety
interface DocumentFile {
  id: string;
  file: File;
  name: string;
  size: number;
  type: string;
  uploadedAt: Date;
  status: 'uploading' | 'processing' | 'completed' | 'error' | 'queued';
  progress: number;
  ocrResults?: OCRResults;
  processingTime?: number;
  errorMessage?: string;
  preview?: string;
  metadata?: DocumentMetadata;
}

interface OCRResults {
  id: string;
  documentId: string;
  extractedText: string;
  confidence: number;
  language: string;
  pageCount: number;
  processingMethod: 'tesseract' | 'ocr_space' | 'google_vision' | 'azure_cognitive';
  structuredData: StructuredData;
  qualityMetrics: QualityMetrics;
  validationResults: ValidationResults;
  createdAt: Date;
  processingTimeMs: number;
}

interface StructuredData {
  documentType: 'income_statement' | 'bank_statement' | 'employment_contract' | 'tax_return' | 'property_valuation' | 'identity_document' | 'other';
  fields: ExtractedField[];
  tables: ExtractedTable[];
  signatures: SignatureInfo[];
  stamps: StampInfo[];
  barcodes: BarcodeInfo[];
  qrCodes: QRCodeInfo[];
}

interface ExtractedField {
  name: string;
  value: string;
  confidence: number;
  boundingBox: BoundingBox;
  dataType: 'text' | 'number' | 'date' | 'currency' | 'percentage' | 'boolean' | 'email' | 'phone' | 'address';
  validated: boolean;
  validationErrors?: string[];
}

interface ExtractedTable {
  id: string;
  rows: TableRow[];
  headers: string[];
  confidence: number;
  boundingBox: BoundingBox;
}

interface TableRow {
  cells: TableCell[];
}

interface TableCell {
  value: string;
  confidence: number;
  dataType: string;
}

interface SignatureInfo {
  id: string;
  boundingBox: BoundingBox;
  confidence: number;
  verified: boolean;
  signerName?: string;
  signatureDate?: Date;
}

interface StampInfo {
  id: string;
  text: string;
  boundingBox: BoundingBox;
  confidence: number;
  stampType: 'official' | 'notary' | 'bank' | 'company' | 'other';
}

interface BarcodeInfo {
  id: string;
  type: 'code128' | 'qr' | 'ean13' | 'pdf417' | 'datamatrix';
  value: string;
  boundingBox: BoundingBox;
  confidence: number;
}

interface QRCodeInfo {
  id: string;
  value: string;
  boundingBox: BoundingBox;
  confidence: number;
  decodedData?: any;
}

interface BoundingBox {
  x: number;
  y: number;
  width: number;
  height: number;
}

interface QualityMetrics {
  overallScore: number;
  textClarity: number;
  imageQuality: number;
  skewAngle: number;
  noiseLevel: number;
  contrast: number;
  brightness: number;
  resolution: number;
  recommendations: string[];
}

interface ValidationResults {
  isValid: boolean;
  validationScore: number;
  issues: ValidationIssue[];
  suggestions: string[];
  complianceChecks: ComplianceCheck[];
}

interface ValidationIssue {
  type: 'error' | 'warning' | 'info';
  field: string;
  message: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  autoFixable: boolean;
}

interface ComplianceCheck {
  rule: string;
  passed: boolean;
  description: string;
  requirement: string;
  impact: 'low' | 'medium' | 'high' | 'critical';
}

interface DocumentMetadata {
  originalName: string;
  mimeType: string;
  fileSize: number;
  dimensions?: { width: number; height: number };
  pageCount?: number;
  createdDate?: Date;
  modifiedDate?: Date;
  author?: string;
  title?: string;
  subject?: string;
  keywords?: string[];
  encrypted: boolean;
  passwordProtected: boolean;
  digitalSignatures?: DigitalSignature[];
}

interface DigitalSignature {
  signerName: string;
  signedAt: Date;
  valid: boolean;
  certificateInfo: CertificateInfo;
}

interface CertificateInfo {
  issuer: string;
  subject: string;
  validFrom: Date;
  validTo: Date;
  serialNumber: string;
  fingerprint: string;
}

interface ProcessingSettings {
  ocrEngine: 'tesseract' | 'ocr_space' | 'google_vision' | 'azure_cognitive' | 'auto';
  language: string;
  enhanceImage: boolean;
  detectTables: boolean;
  detectSignatures: boolean;
  detectBarcodes: boolean;
  extractStructuredData: boolean;
  validateFields: boolean;
  confidenceThreshold: number;
  outputFormat: 'json' | 'xml' | 'csv' | 'txt';
  includeCoordinates: boolean;
  preserveLayout: boolean;
}

const DocumentOCRProcessor: React.FC = () => {
  const navigate = useNavigate();
  const { isDemoMode } = useDemoMode();
  const { currentClientId } = useClient();
  const { width } = useViewportSize();
  const isMobile = width < 768;

  // Document processing state
  const [documents, setDocuments] = useState<DocumentFile[]>([]);
  const [selectedDocument, setSelectedDocument] = useState<DocumentFile | null>(null);
  const [processingQueue, setProcessingQueue] = useState<string[]>([]);
  const [isProcessing, setIsProcessing] = useState(false);
  const [batchProgress, setBatchProgress] = useState(0);

  // UI state
  const [activeTab, setActiveTab] = useState('upload');
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');
  const [filterType, setFilterType] = useState<string>('all');
  const [sortBy, setSortBy] = useState<'name' | 'date' | 'size' | 'status'>('date');
  const [searchQuery, setSearchQuery] = useState('');

  // Processing settings
  const [processingSettings, setProcessingSettings] = useLocalStorage<ProcessingSettings>({
    key: 'ocr-processing-settings',
    defaultValue: {
      ocrEngine: 'auto',
      language: 'nld',
      enhanceImage: true,
      detectTables: true,
      detectSignatures: true,
      detectBarcodes: true,
      extractStructuredData: true,
      validateFields: true,
      confidenceThreshold: 0.7,
      outputFormat: 'json',
      includeCoordinates: true,
      preserveLayout: true
    }
  });

  // Modal states
  const [settingsOpened, { open: openSettings, close: closeSettings }] = useDisclosure(false);
  const [previewOpened, { open: openPreview, close: closePreview }] = useDisclosure(false);
  const [resultsOpened, { open: openResults, close: closeResults }] = useDisclosure(false);
  const [exportOpened, { open: openExport, close: closeExport }] = useDisclosure(false);

  // Refs
  const fileInputRef = useRef<HTMLInputElement>(null);
  const dropZoneRef = useRef<HTMLDivElement>(null);
  const processingWorkerRef = useRef<Worker | null>(null);

  /**
   * Initialize OCR processing worker
   */
  useEffect(() => {
    // Initialize web worker for background processing
    if (typeof Worker !== 'undefined') {
      processingWorkerRef.current = new Worker('/workers/ocr-processor.js');
      
      processingWorkerRef.current.onmessage = (event) => {
        const { type, documentId, data, error } = event.data;
        
        switch (type) {
          case 'progress':
            updateDocumentProgress(documentId, data.progress);
            break;
          case 'completed':
            handleProcessingComplete(documentId, data);
            break;
          case 'error':
            handleProcessingError(documentId, error);
            break;
        }
      };
    }

    return () => {
      if (processingWorkerRef.current) {
        processingWorkerRef.current.terminate();
      }
    };
  }, []);

  /**
   * Handle successful document processing completion
   */
  const handleProcessingComplete = useCallback((documentId: string, data: any) => {
    setDocuments(prev => prev.map(doc => 
      doc.id === documentId ? {
        ...doc,
        status: 'completed',
        progress: 100,
        ocrResults: data,
        processingTime: data.processingTime || 0
      } : doc
    ));
    
    notifications.show({
      title: 'Document verwerkt',
      message: 'OCR verwerking succesvol voltooid',
      color: 'green',
      icon: <IconCheck size={16} />
    });
  }, []);

  /**
   * Handle document processing errors
   */
  const handleProcessingError = useCallback((documentId: string, error: string) => {
    setDocuments(prev => prev.map(doc => 
      doc.id === documentId ? {
        ...doc,
        status: 'error',
        progress: 0,
        errorMessage: error
      } : doc
    ));
    
    notifications.show({
      title: 'Verwerkingsfout',
      message: error || 'Er is een fout opgetreden tijdens de verwerking',
      color: 'red',
      icon: <IconX size={16} />
    });
  }, []);

  /**
   * Handle file upload via drag and drop or file input
   */
  const handleFileUpload = useCallback(async (files: File[]) => {
    const supportedTypes = [
      'application/pdf',
      'image/jpeg',
      'image/jpg',
      'image/png',
      'image/tiff',
      'image/bmp',
      'image/webp'
    ];

    const validFiles = files.filter(file => {
      if (!supportedTypes.includes(file.type)) {
        notifications.show({
          title: 'Niet ondersteund bestandstype',
          message: `${file.name} wordt niet ondersteund. Gebruik PDF, JPEG, PNG, TIFF, BMP of WebP.`,
          color: 'red',
          icon: <IconX size={16} />
        });
        return false;
      }

      if (file.size > 50 * 1024 * 1024) { // 50MB limit
        notifications.show({
          title: 'Bestand te groot',
          message: `${file.name} is groter dan 50MB. Kies een kleiner bestand.`,
          color: 'red',
          icon: <IconX size={16} />
        });
        return false;
      }

      return true;
    });

    if (validFiles.length === 0) return;

    const newDocuments: DocumentFile[] = await Promise.all(
      validFiles.map(async (file) => {
        const id = `doc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const preview = await generatePreview(file);
        
        return {
          id,
          file,
          name: file.name,
          size: file.size,
          type: file.type,
          uploadedAt: new Date(),
          status: 'queued',
          progress: 0,
          preview,
          metadata: await extractMetadata(file)
        };
      })
    );

    setDocuments(prev => [...prev, ...newDocuments]);
    
    // Start processing if not already processing
    if (!isProcessing) {
      startBatchProcessing([...documents, ...newDocuments]);
    }

    notifications.show({
      title: 'Bestanden toegevoegd',
      message: `${validFiles.length} bestand(en) toegevoegd aan verwerkingsqueue`,
      color: 'green',
      icon: <IconCheck size={16} />
    });
  }, [documents, isProcessing]);

  /**
   * Generate preview for uploaded file
   */
  const generatePreview = useCallback(async (file: File): Promise<string | undefined> => {
    return new Promise((resolve) => {
      if (file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target?.result as string);
        reader.onerror = () => resolve(undefined);
        reader.readAsDataURL(file);
      } else if (file.type === 'application/pdf') {
        // For PDF, we would use PDF.js to generate thumbnail
        // For now, return undefined and show PDF icon
        resolve(undefined);
      } else {
        resolve(undefined);
      }
    });
  }, []);

  /**
   * Extract metadata from file
   */
  const extractMetadata = useCallback(async (file: File): Promise<DocumentMetadata> => {
    const metadata: DocumentMetadata = {
      originalName: file.name,
      mimeType: file.type,
      fileSize: file.size,
      createdDate: new Date(file.lastModified),
      modifiedDate: new Date(file.lastModified),
      encrypted: false,
      passwordProtected: false
    };

    // For images, extract dimensions
    if (file.type.startsWith('image/')) {
      try {
        const dimensions = await getImageDimensions(file);
        metadata.dimensions = dimensions;
      } catch (error) {
        console.warn('Failed to extract image dimensions:', error);
      }
    }

    return metadata;
  }, []);

  /**
   * Get image dimensions
   */
  const getImageDimensions = useCallback((file: File): Promise<{ width: number; height: number }> => {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        resolve({ width: img.naturalWidth, height: img.naturalHeight });
      };
      img.onerror = reject;
      img.src = URL.createObjectURL(file);
    });
  }, []);

  /**
   * Start batch processing of documents
   */
  const startBatchProcessing = useCallback(async (documentsToProcess: DocumentFile[]) => {
    const queuedDocs = documentsToProcess.filter(doc => doc.status === 'queued');
    
    if (queuedDocs.length === 0) return;

    setIsProcessing(true);
    setBatchProgress(0);
    setProcessingQueue(queuedDocs.map(doc => doc.id));

    let completedCount = 0;

    for (const doc of queuedDocs) {
      try {
        await processDocument(doc);
        completedCount++;
        setBatchProgress((completedCount / queuedDocs.length) * 100);
      } catch (error) {
        console.error(`Failed to process document ${doc.id}:`, error);
        updateDocumentStatus(doc.id, 'error', `Processing failed: ${error}`);
      }
    }

    setIsProcessing(false);
    setProcessingQueue([]);
    setBatchProgress(0);

    notifications.show({
      title: 'Verwerking voltooid',
      message: `${completedCount} van ${queuedDocs.length} documenten succesvol verwerkt`,
      color: completedCount === queuedDocs.length ? 'green' : 'orange',
      icon: <IconCheck size={16} />
    });
  }, []);

  /**
   * Process individual document
   */
  const processDocument = useCallback(async (document: DocumentFile): Promise<void> => {
    updateDocumentStatus(document.id, 'processing');

    try {
      if (isDemoMode) {
        // Demo mode - simulate processing with mock data
        await simulateProcessing(document);
      } else {
        // Production mode - actual OCR processing
        await performOCRProcessing(document);
      }
    } catch (error) {
      throw error;
    }
  }, [isDemoMode, processingSettings]);

  /**
   * Simulate OCR processing for demo mode
   */
  const simulateProcessing = useCallback(async (document: DocumentFile): Promise<void> => {
    const steps = [
      { progress: 10, message: 'Bestand uploaden...' },
      { progress: 25, message: 'Afbeelding voorbewerken...' },
      { progress: 40, message: 'OCR analyse uitvoeren...' },
      { progress: 60, message: 'Tekst extraheren...' },
      { progress: 75, message: 'Gestructureerde data herkennen...' },
      { progress: 90, message: 'Validatie uitvoeren...' },
      { progress: 100, message: 'Verwerking voltooid' }
    ];

    for (const step of steps) {
      await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 1000));
      updateDocumentProgress(document.id, step.progress);
    }

    // Generate mock OCR results
    const mockResults: OCRResults = {
      id: `ocr_${document.id}`,
      documentId: document.id,
      extractedText: generateMockExtractedText(document.name),
      confidence: 0.85 + Math.random() * 0.1,
      language: 'nld',
      pageCount: 1,
      processingMethod: 'tesseract',
      structuredData: generateMockStructuredData(document.name),
      qualityMetrics: generateMockQualityMetrics(),
      validationResults: generateMockValidationResults(),
      createdAt: new Date(),
      processingTimeMs: 2000 + Math.random() * 3000
    };

    updateDocumentResults(document.id, mockResults);
    updateDocumentStatus(document.id, 'completed');
  }, []);

  /**
   * Perform actual OCR processing
   */
  const performOCRProcessing = useCallback(async (document: DocumentFile): Promise<void> => {
    const formData = new FormData();
    formData.append('file', document.file);
    formData.append('settings', JSON.stringify(processingSettings));
    formData.append('clientId', currentClientId || 'anonymous');

    const response = await fetch('/api/quality-control/process-document', {
      method: 'POST',
      body: formData,
      headers: {
        'X-Document-ID': document.id
      }
    });

    if (!response.ok) {
      throw new Error(`OCR processing failed: ${response.statusText}`);
    }

    const result = await response.json();
    
    updateDocumentResults(document.id, result.ocrResults);
    updateDocumentStatus(document.id, 'completed');
  }, [processingSettings, currentClientId]);

  /**
   * Generate mock extracted text based on document name
   */
  const generateMockExtractedText = useCallback((fileName: string): string => {
    const lowerName = fileName.toLowerCase();
    
    if (lowerName.includes('loonstrook') || lowerName.includes('salary') || lowerName.includes('payslip')) {
      return `LOONSTROOK
Werkgever: ABC Bedrijf B.V.
Werknemer: Jan de Vries
BSN: 123456789
Periode: Januari 2024

INKOMSTEN:
Bruto loon: € 4.500,00
Vakantietoeslag: € 360,00
Totaal bruto: € 4.860,00

INHOUDINGEN:
Loonheffing: € 1.215,00
Pensioenpremie: € 243,00
Totaal inhoudingen: € 1.458,00

NETTO UITBETALING: € 3.402,00`;
    }
    
    if (lowerName.includes('bank') || lowerName.includes('rekening') || lowerName.includes('statement')) {
      return `BANKAFSCHRIFT
ING Bank N.V.
Rekeningnummer: NL91 INGB 0002 4455 88
Periode: 01-01-2024 t/m 31-01-2024

TRANSACTIES:
01-01 Saldo vorig overzicht: € 12.450,67
03-01 Salaris ABC Bedrijf: € 3.402,00
05-01 Hypotheek betaling: € -1.250,00
10-01 Boodschappen AH: € -89,45
15-01 Energierekening: € -145,00

Eindsaldo: € 14.368,22`;
    }

    return `DOCUMENT INHOUD
Dit is een voorbeeld van geëxtraheerde tekst uit het document.
De OCR-engine heeft de volgende informatie herkend:

- Datum: ${new Date().toLocaleDateString('nl-NL')}
- Document type: Algemeen document
- Betrouwbaarheid: Hoog
- Taal: Nederlands

Verdere details zijn beschikbaar in de gestructureerde data sectie.`;
  }, []);

  /**
   * Generate mock structured data
   */
  const generateMockStructuredData = useCallback((fileName: string): StructuredData => {
    const lowerName = fileName.toLowerCase();
    let documentType: StructuredData['documentType'] = 'other';
    let fields: ExtractedField[] = [];

    if (lowerName.includes('loonstrook') || lowerName.includes('salary') || lowerName.includes('payslip')) {
      documentType = 'income_statement';
      fields = [
        {
          name: 'werkgever',
          value: 'ABC Bedrijf B.V.',
          confidence: 0.95,
          boundingBox: { x: 100, y: 50, width: 200, height: 20 },
          dataType: 'text',
          validated: true
        },
        {
          name: 'werknemer',
          value: 'Jan de Vries',
          confidence: 0.92,
          boundingBox: { x: 100, y: 80, width: 150, height: 20 },
          dataType: 'text',
          validated: true
        },
        {
          name: 'bruto_loon',
          value: '€ 4.500,00',
          confidence: 0.98,
          boundingBox: { x: 200, y: 150, width: 100, height: 20 },
          dataType: 'currency',
          validated: true
        },
        {
          name: 'netto_loon',
          value: '€ 3.402,00',
          confidence: 0.97,
          boundingBox: { x: 200, y: 250, width: 100, height: 20 },
          dataType: 'currency',
          validated: true
        }
      ];
    } else if (lowerName.includes('bank') || lowerName.includes('rekening')) {
      documentType = 'bank_statement';
      fields = [
        {
          name: 'rekeningnummer',
          value: 'NL91 INGB 0002 4455 88',
          confidence: 0.96,
          boundingBox: { x: 150, y: 60, width: 200, height: 20 },
          dataType: 'text',
          validated: true
        },
        {
          name: 'eindsaldo',
          value: '€ 14.368,22',
          confidence: 0.99,
          boundingBox: { x: 200, y: 300, width: 120, height: 20 },
          dataType: 'currency',
          validated: true
        }
      ];
    }

    return {
      documentType,
      fields,
      tables: [],
      signatures: [],
      stamps: [],
      barcodes: [],
      qrCodes: []
    };
  }, []);

  /**
   * Generate mock quality metrics
   */
  const generateMockQualityMetrics = useCallback((): QualityMetrics => ({
    overallScore: 0.85 + Math.random() * 0.1,
    textClarity: 0.9 + Math.random() * 0.05,
    imageQuality: 0.8 + Math.random() * 0.15,
    skewAngle: Math.random() * 2 - 1,
    noiseLevel: Math.random() * 0.2,
    contrast: 0.7 + Math.random() * 0.2,
    brightness: 0.6 + Math.random() * 0.3,
    resolution: 300 + Math.random() * 200,
    recommendations: [
      'Afbeeldingskwaliteit is goed voor OCR',
      'Tekst is duidelijk leesbaar',
      'Geen significante vervormingen gedetecteerd'
    ]
  }), []);

  /**
   * Generate mock validation results
   */
  const generateMockValidationResults = useCallback((): ValidationResults => ({
    isValid: true,
    validationScore: 0.9 + Math.random() * 0.08,
    issues: [],
    suggestions: [
      'Document voldoet aan kwaliteitseisen',
      'Alle verplichte velden zijn herkend',
      'Gestructureerde data is compleet'
    ],
    complianceChecks: [
      {
        rule: 'AFM_DOC_001',
        passed: true,
        description: 'Document bevat vereiste identificatie-informatie',
        requirement: 'Naam en BSN moeten aanwezig zijn',
        impact: 'high'
      },
      {
        rule: 'AFM_DOC_002',
        passed: true,
        description: 'Financiële gegevens zijn volledig',
        requirement: 'Inkomsten en uitgaven moeten gedocumenteerd zijn',
        impact: 'critical'
      }
    ]
  }), []);

  /**
   * Update document progress
   */
  const updateDocumentProgress = useCallback((documentId: string, progress: number) => {
    setDocuments(prev => prev.map(doc => 
      doc.id === documentId 
        ? { ...doc, progress }
        : doc
    ));
  }, []);

  /**
   * Update document status
   */
  const updateDocumentStatus = useCallback((documentId: string, status: DocumentFile['status'], errorMessage?: string) => {
    setDocuments(prev => prev.map(doc => 
      doc.id === documentId 
        ? { ...doc, status, errorMessage }
        : doc
    ));
  }, []);

  /**
   * Update document with OCR results
   */
  const updateDocumentResults = useCallback((documentId: string, results: OCRResults) => {
    setDocuments(prev => prev.map(doc => 
      doc.id === documentId 
        ? { 
            ...doc, 
            ocrResults: results,
            processingTime: results.processingTimeMs
          }
        : doc
    ));
  }, []);

  /**
   * Handle document deletion
   */
  const handleDeleteDocument = useCallback((documentId: string) => {
    modals.openConfirmModal({
      title: 'Document verwijderen',
      children: 'Weet u zeker dat u dit document wilt verwijderen? Deze actie kan niet ongedaan worden gemaakt.',
      labels: { confirm: 'Verwijderen', cancel: 'Annuleren' },
      confirmProps: { color: 'red' },
      onConfirm: () => {
        setDocuments(prev => prev.filter(doc => doc.id !== documentId));
        notifications.show({
          title: 'Document verwijderd',
          message: 'Het document is succesvol verwijderd',
          color: 'green',
          icon: <IconCheck size={16} />
        });
      }
    });
  }, []);

  /**
   * Handle document reprocessing
   */
  const handleReprocessDocument = useCallback(async (documentId: string) => {
    const document = documents.find(doc => doc.id === documentId);
    if (!document) return;

    updateDocumentStatus(documentId, 'queued');
    await processDocument(document);
  }, [documents, processDocument]);

  /**
   * Export document results
   */
  const handleExportResults = useCallback((document: DocumentFile) => {
    if (!document.ocrResults) return;

    const exportData = {
      document: {
        name: document.name,
        size: document.size,
        type: document.type,
        uploadedAt: document.uploadedAt,
        processingTime: document.processingTime
      },
      ocrResults: document.ocrResults,
      exportedAt: new Date().toISOString()
    };

    const blob = new Blob([JSON.stringify(exportData, null, 2)], {
      type: 'application/json'
    });

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `ocr-results-${document.name}-${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    notifications.show({
      title: 'Resultaten geëxporteerd',
      message: 'OCR resultaten zijn gedownload als JSON bestand',
      color: 'green',
      icon: <IconDownload size={16} />
    });
  }, []);

  /**
   * Filter and sort documents
   */
  const filteredDocuments = useMemo(() => {
    let filtered = documents;

    // Filter by type
    if (filterType !== 'all') {
      filtered = filtered.filter(doc => doc.status === filterType);
    }

    // Filter by search query
    if (searchQuery) {
      filtered = filtered.filter(doc => 
        doc.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
        doc.ocrResults?.extractedText.toLowerCase().includes(searchQuery.toLowerCase())
      );
    }

    // Sort documents
    filtered.sort((a, b) => {
      switch (sortBy) {
        case 'name':
          return a.name.localeCompare(b.name);
        case 'date':
          return b.uploadedAt.getTime() - a.uploadedAt.getTime();
        case 'size':
          return b.size - a.size;
        case 'status':
          return a.status.localeCompare(b.status);
        default:
          return 0;
      }
    });

    return filtered;
  }, [documents, filterType, searchQuery, sortBy]);

  /**
   * Render document card
   */
  const renderDocumentCard = useCallback((document: DocumentFile) => {
    const getStatusColor = (status: DocumentFile['status']) => {
      switch (status) {
        case 'completed': return 'green';
        case 'processing': return 'blue';
        case 'error': return 'red';
        case 'queued': return 'orange';
        default: return 'gray';
      }
    };

    const getStatusIcon = (status: DocumentFile['status']) => {
      switch (status) {
        case 'completed': return <IconCheck size={16} />;
        case 'processing': return <Loader size={16} />;
        case 'error': return <IconX size={16} />;
        case 'queued': return <IconClock size={16} />;
        default: return <IconFile size={16} />;
      }
    };

    return (
      <Card key={document.id} shadow="sm" padding="md" radius="md" withBorder>
        <Stack gap="sm">
          {/* Document Header */}
          <Group justify="space-between" align="flex-start">
            <Group gap="sm">
              <ThemeIcon
                size="lg"
                radius="md"
                variant="light"
                color={document.type.includes('pdf') ? 'red' : 'blue'}
              >
                {document.type.includes('pdf') ? (
                  <IconFilePdf size={20} />
                ) : (
                  <IconPhoto size={20} />
                )}
              </ThemeIcon>
              <div>
                <Text size="sm" fw={500} lineClamp={1}>
                  {document.name}
                </Text>
                <Text size="xs" c="dimmed">
                  {(document.size / 1024 / 1024).toFixed(2)} MB
                </Text>
              </div>
            </Group>

            <Menu shadow="md" width={200}>
              <Menu.Target>
                <ActionIcon variant="subtle" size="sm">
                  <IconSettings size={16} />
                </ActionIcon>
              </Menu.Target>
              <Menu.Dropdown>
                <Menu.Item
                  leftSection={<IconEye size={14} />}
                  onClick={() => {
                    setSelectedDocument(document);
                    openPreview();
                  }}
                >
                  Bekijk
                </Menu.Item>
                {document.ocrResults && (
                  <Menu.Item
                    leftSection={<IconChartBar size={14} />}
                    onClick={() => {
                      setSelectedDocument(document);
                      openResults();
                    }}
                  >
                    Resultaten
                  </Menu.Item>
                )}
                {document.status === 'error' && (
                  <Menu.Item
                    leftSection={<IconRefresh size={14} />}
                    onClick={() => handleReprocessDocument(document.id)}
                  >
                    Opnieuw verwerken
                  </Menu.Item>
                )}
                {document.ocrResults && (
                  <Menu.Item
                    leftSection={<IconDownload size={14} />}
                    onClick={() => handleExportResults(document)}
                  >
                    Exporteren
                  </Menu.Item>
                )}
                <Menu.Divider />
                <Menu.Item
                  leftSection={<IconTrash size={14} />}
                  color="red"
                  onClick={() => handleDeleteDocument(document.id)}
                >
                  Verwijderen
                </Menu.Item>
              </Menu.Dropdown>
            </Menu>
          </Group>

          {/* Document Preview */}
          {document.preview && (
            <Image
              src={document.preview}
              alt={document.name}
              height={120}
              fit="cover"
              radius="sm"
            />
          )}

          {/* Status and Progress */}
          <Group justify="space-between" align="center">
            <Badge
              color={getStatusColor(document.status)}
              variant="light"
              leftSection={getStatusIcon(document.status)}
            >
              {document.status === 'completed' && 'Voltooid'}
              {document.status === 'processing' && 'Verwerken...'}
              {document.status === 'error' && 'Fout'}
              {document.status === 'queued' && 'In wachtrij'}
              {document.status === 'uploading' && 'Uploaden...'}
            </Badge>

            {document.ocrResults && (
              <Badge variant="light" color="blue">
                {Math.round(document.ocrResults.confidence * 100)}% betrouwbaar
              </Badge>
            )}
          </Group>

          {/* Progress Bar */}
          {(document.status === 'processing' || document.status === 'uploading') && (
            <Progress value={document.progress} size="sm" radius="xl" />
          )}

          {/* Error Message */}
          {document.status === 'error' && document.errorMessage && (
            <Alert
              icon={<IconAlertTriangle size={16} />}
              title="Verwerkingsfout"
              color="red"
              size="sm"
            >
              {document.errorMessage}
            </Alert>
          )}

          {/* OCR Results Summary */}
          {document.ocrResults && (
            <Paper p="xs" withBorder radius="sm">
              <Stack gap="xs">
                <Group justify="space-between">
                  <Text size="xs" fw={500}>Geëxtraheerde tekst:</Text>
                  <Text size="xs" c="dimmed">
                    {document.ocrResults.extractedText.length} karakters
                  </Text>
                </Group>
                <Text size="xs" lineClamp={2} c="dimmed">
                  {document.ocrResults.extractedText}
                </Text>
                {document.ocrResults.structuredData.fields.length > 0 && (
                  <Group gap="xs">
                    <Text size="xs" c="dimmed">Velden:</Text>
                    <Badge size="xs" variant="dot">
                      {document.ocrResults.structuredData.fields.length}
                    </Badge>
                  </Group>
                )}
              </Stack>
            </Paper>
          )}
        </Stack>
      </Card>
    );
  }, [handleDeleteDocument, handleReprocessDocument, handleExportResults, openPreview, openResults]);

  return (
    <Container size="xl" py="md">
      <Stack gap="md">
        {/* Header */}
        <Card shadow="sm" padding="lg" radius="md">
          <Group justify="space-between" align="center">
            <Group gap="md">
              <ThemeIcon size="xl" radius="md" variant="gradient" gradient={{ from: 'blue', to: 'cyan' }}>
                <IconScan size={24} />
              </ThemeIcon>
              <div>
                <Text size="xl" fw={700}>Document OCR Processor</Text>
                <Text size="sm" c="dimmed">
                  Geavanceerde documentverwerking met OCR en AI-analyse
                </Text>
              </div>
            </Group>

            <Group gap="xs">
              {/* Demo Mode Indicator */}
              {isDemoMode && (
                <Badge color="orange" variant="light">
                  Demo Modus
                </Badge>
              )}

              {/* Processing Status */}
              {isProcessing && (
                <Badge color="blue" variant="light" leftSection={<Loader size={12} />}>
                  Verwerken... {Math.round(batchProgress)}%
                </Badge>
              )}

              {/* Settings */}
              <ActionIcon variant="light" size="lg" onClick={openSettings}>
                <IconSettings size={18} />
              </ActionIcon>
            </Group>
          </Group>
        </Card>

        {/* Main Content */}
        <Tabs value={activeTab} onChange={setActiveTab}>
          <Tabs.List>
            <Tabs.Tab value="upload" leftSection={<IconUpload size={16} />}>
              Upload
            </Tabs.Tab>
            <Tabs.Tab value="documents" leftSection={<IconFile size={16} />}>
              Documenten ({documents.length})
            </Tabs.Tab>
            <Tabs.Tab value="results" leftSection={<IconChartBar size={16} />}>
              Resultaten
            </Tabs.Tab>
            <Tabs.Tab value="analytics" leftSection={<IconBrain size={16} />}>
              Analytics
            </Tabs.Tab>
          </Tabs.List>

          {/* Upload Tab */}
          <Tabs.Panel value="upload" pt="md">
            <Card shadow="sm" padding="xl" radius="md">
              <Stack gap="xl" align="center">
                <div
                  ref={dropZoneRef}
                  style={{
                    border: '2px dashed var(--mantine-color-gray-4)',
                    borderRadius: '8px',
                    padding: '60px 40px',
                    textAlign: 'center',
                    cursor: 'pointer',
                    transition: 'all 0.2s ease',
                    width: '100%',
                    maxWidth: '600px'
                  }}
                  onClick={() => fileInputRef.current?.click()}
                  onDragOver={(e) => {
                    e.preventDefault();
                    e.currentTarget.style.borderColor = 'var(--mantine-color-blue-6)';
                    e.currentTarget.style.backgroundColor = 'var(--mantine-color-blue-0)';
                  }}
                  onDragLeave={(e) => {
                    e.currentTarget.style.borderColor = 'var(--mantine-color-gray-4)';
                    e.currentTarget.style.backgroundColor = 'transparent';
                  }}
                  onDrop={(e) => {
                    e.preventDefault();
                    e.currentTarget.style.borderColor = 'var(--mantine-color-gray-4)';
                    e.currentTarget.style.backgroundColor = 'transparent';
                    
                    const files = Array.from(e.dataTransfer.files);
                    handleFileUpload(files);
                  }}
                >
                  <Stack gap="md" align="center">
                    <ThemeIcon size={60} radius="xl" variant="light" color="blue">
                      <IconCloudUpload size={30} />
                    </ThemeIcon>
                    <div>
                      <Text size="lg" fw={500}>
                        Sleep bestanden hierheen of klik om te uploaden
                      </Text>
                      <Text size="sm" c="dimmed" mt="xs">
                        Ondersteunt PDF, JPEG, PNG, TIFF, BMP en WebP bestanden tot 50MB
                      </Text>
                    </div>
                    <Button variant="light" size="lg">
                      Bestanden selecteren
                    </Button>
                  </Stack>
                </div>

                <input
                  ref={fileInputRef}
                  type="file"
                  multiple
                  accept=".pdf,.jpg,.jpeg,.png,.tiff,.bmp,.webp"
                  style={{ display: 'none' }}
                  onChange={(e) => {
                    const files = Array.from(e.target.files || []);
                    handleFileUpload(files);
                    e.target.value = '';
                  }}
                />

                {/* Processing Queue Status */}
                {isProcessing && (
                  <Paper p="md" withBorder radius="md" style={{ width: '100%', maxWidth: '600px' }}>
                    <Stack gap="sm">
                      <Group justify="space-between">
                        <Text size="sm" fw={500}>Verwerkingsvoortgang</Text>
                        <Text size="sm" c="dimmed">{Math.round(batchProgress)}%</Text>
                      </Group>
                      <Progress value={batchProgress} size="lg" radius="xl" />
                      <Text size="xs" c="dimmed">
                        {processingQueue.length} document(en) in verwerking
                      </Text>
                    </Stack>
                  </Paper>
                )}

                {/* Quick Actions */}
                <SimpleGrid cols={isMobile ? 2 : 4} spacing="md" style={{ width: '100%', maxWidth: '600px' }}>
                  <Button
                    variant="light"
                    leftSection={<IconFilePdf size={16} />}
                    onClick={() => fileInputRef.current?.click()}
                  >
                    PDF Upload
                  </Button>
                  <Button
                    variant="light"
                    leftSection={<IconPhoto size={16} />}
                    onClick={() => fileInputRef.current?.click()}
                  >
                    Afbeelding
                  </Button>
                  <Button
                    variant="light"
                    leftSection={<IconScan size={16} />}
                    onClick={() => {
                      notifications.show({
                        title: 'Binnenkort beschikbaar',
                        message: 'Scanner integratie wordt binnenkort toegevoegd',
                        color: 'blue'
                      });
                    }}
                  >
                    Scannen
                  </Button>
                  <Button
                    variant="light"
                    leftSection={<IconSettings size={16} />}
                    onClick={openSettings}
                  >
                    Instellingen
                  </Button>
                </SimpleGrid>
              </Stack>
            </Card>
          </Tabs.Panel>

          {/* Documents Tab */}
          <Tabs.Panel value="documents" pt="md">
            <Stack gap="md">
              {/* Filters and Controls */}
              <Card shadow="sm" padding="md" radius="md">
                <Group justify="space-between" align="center">
                  <Group gap="md">
                    <Select
                      placeholder="Filter op status"
                      value={filterType}
                      onChange={(value) => setFilterType(value || 'all')}
                      data={[
                        { value: 'all', label: 'Alle documenten' },
                        { value: 'completed', label: 'Voltooid' },
                        { value: 'processing', label: 'Verwerken' },
                        { value: 'queued', label: 'In wachtrij' },
                        { value: 'error', label: 'Fout' }
                      ]}
                      style={{ width: 200 }}
                    />

                    <Select
                      placeholder="Sorteer op"
                      value={sortBy}
                      onChange={(value) => setSortBy(value as any || 'date')}
                      data={[
                        { value: 'date', label: 'Datum' },
                        { value: 'name', label: 'Naam' },
                        { value: 'size', label: 'Grootte' },
                        { value: 'status', label: 'Status' }
                      ]}
                      style={{ width: 150 }}
                    />
                  </Group>

                  <Group gap="xs">
                    <ActionIcon
                      variant={viewMode === 'grid' ? 'filled' : 'light'}
                      onClick={() => setViewMode('grid')}
                    >
                      <IconDeviceDesktop size={16} />
                    </ActionIcon>
                    <ActionIcon
                      variant={viewMode === 'list' ? 'filled' : 'light'}
                      onClick={() => setViewMode('list')}
                    >
                      <IconFile size={16} />
                    </ActionIcon>
                  </Group>
                </Group>
              </Card>

              {/* Documents Grid/List */}
              {filteredDocuments.length === 0 ? (
                <Card shadow="sm" padding="xl" radius="md">
                  <Stack gap="md" align="center">
                    <ThemeIcon size="xl" radius="xl" variant="light" color="gray">
                      <IconFile size={24} />
                    </ThemeIcon>
                    <div style={{ textAlign: 'center' }}>
                      <Text size="lg" fw={500}>Geen documenten gevonden</Text>
                      <Text size="sm" c="dimmed" mt="xs">
                        Upload documenten om te beginnen met OCR verwerking
                      </Text>
                    </div>
                    <Button
                      variant="light"
                      leftSection={<IconUpload size={16} />}
                      onClick={() => setActiveTab('upload')}
                    >
                      Documenten uploaden
                    </Button>
                  </Stack>
                </Card>
              ) : (
                <SimpleGrid cols={isMobile ? 1 : viewMode === 'grid' ? 3 : 1} spacing="md">
                  {filteredDocuments.map(renderDocumentCard)}
                </SimpleGrid>
              )}
            </Stack>
          </Tabs.Panel>

          {/* Results Tab */}
          <Tabs.Panel value="results" pt="md">
            <Card shadow="sm" padding="lg" radius="md">
              <Stack gap="md">
                <Text size="lg" fw={500}>Verwerkingsresultaten</Text>
                
                {documents.filter(doc => doc.ocrResults).length === 0 ? (
                  <Stack gap="md" align="center" py="xl">
                    <ThemeIcon size="xl" radius="xl" variant="light" color="gray">
                      <IconChartBar size={24} />
                    </ThemeIcon>
                    <div style={{ textAlign: 'center' }}>
                      <Text size="lg" fw={500}>Nog geen resultaten beschikbaar</Text>
                      <Text size="sm" c="dimmed" mt="xs">
                        Verwerk documenten om resultaten te bekijken
                      </Text>
                    </div>
                  </Stack>
                ) : (
                  <SimpleGrid cols={isMobile ? 1 : 2} spacing="md">
                    {documents
                      .filter(doc => doc.ocrResults)
                      .map(doc => (
                        <Paper key={doc.id} p="md" withBorder radius="md">
                          <Stack gap="sm">
                            <Group justify="space-between">
                              <Text size="sm" fw={500} lineClamp={1}>
                                {doc.name}
                              </Text>
                              <Badge variant="light" color="green">
                                {Math.round(doc.ocrResults!.confidence * 100)}%
                              </Badge>
                            </Group>
                            
                            <Text size="xs" lineClamp={3} c="dimmed">
                              {doc.ocrResults!.extractedText}
                            </Text>
                            
                            <Group justify="space-between">
                              <Text size="xs" c="dimmed">
                                {doc.ocrResults!.structuredData.fields.length} velden
                              </Text>
                              <Button
                                size="xs"
                                variant="light"
                                onClick={() => {
                                  setSelectedDocument(doc);
                                  openResults();
                                }}
                              >
                                Details
                              </Button>
                            </Group>
                          </Stack>
                        </Paper>
                      ))}
                  </SimpleGrid>
                )}
              </Stack>
            </Card>
          </Tabs.Panel>

          {/* Analytics Tab */}
          <Tabs.Panel value="analytics" pt="md">
            <SimpleGrid cols={isMobile ? 1 : 2} spacing="md">
              {/* Processing Statistics */}
              <Card shadow="sm" padding="lg" radius="md">
                <Stack gap="md">
                  <Text size="lg" fw={500}>Verwerkingsstatistieken</Text>
                  
                  <SimpleGrid cols={2} spacing="md">
                    <Paper p="md" withBorder radius="md" style={{ textAlign: 'center' }}>
                      <Text size="xl" fw={700} c="blue">
                        {documents.length}
                      </Text>
                      <Text size="sm" c="dimmed">Totaal documenten</Text>
                    </Paper>
                    
                    <Paper p="md" withBorder radius="md" style={{ textAlign: 'center' }}>
                      <Text size="xl" fw={700} c="green">
                        {documents.filter(doc => doc.status === 'completed').length}
                      </Text>
                      <Text size="sm" c="dimmed">Voltooid</Text>
                    </Paper>
                    
                    <Paper p="md" withBorder radius="md" style={{ textAlign: 'center' }}>
                      <Text size="xl" fw={700} c="orange">
                        {documents.filter(doc => doc.status === 'processing' || doc.status === 'queued').length}
                      </Text>
                      <Text size="sm" c="dimmed">In verwerking</Text>
                    </Paper>
                    
                    <Paper p="md" withBorder radius="md" style={{ textAlign: 'center' }}>
                      <Text size="xl" fw={700} c="red">
                        {documents.filter(doc => doc.status === 'error').length}
                      </Text>
                      <Text size="sm" c="dimmed">Fouten</Text>
                    </Paper>
                  </SimpleGrid>
                </Stack>
              </Card>

              {/* Quality Metrics */}
              <Card shadow="sm" padding="lg" radius="md">
                <Stack gap="md">
                  <Text size="lg" fw={500}>Kwaliteitsmetrieken</Text>
                  
                  {documents.filter(doc => doc.ocrResults).length > 0 ? (
                    <Stack gap="sm">
                      {(() => {
                        const completedDocs = documents.filter(doc => doc.ocrResults);
                        const avgConfidence = completedDocs.reduce((sum, doc) => 
                          sum + doc.ocrResults!.confidence, 0) / completedDocs.length;
                        const avgProcessingTime = completedDocs.reduce((sum, doc) => 
                          sum + (doc.processingTime || 0), 0) / completedDocs.length;

                        return (
                          <>
                            <Group justify="space-between">
                              <Text size="sm">Gemiddelde betrouwbaarheid</Text>
                              <Badge variant="light" color="blue">
                                {Math.round(avgConfidence * 100)}%
                              </Badge>
                            </Group>
                            
                            <Progress 
                              value={avgConfidence * 100} 
                              size="sm" 
                              radius="xl"
                              color="blue"
                            />
                            
                            <Group justify="space-between">
                              <Text size="sm">Gemiddelde verwerkingstijd</Text>
                              <Text size="sm" c="dimmed">
                                {(avgProcessingTime / 1000).toFixed(1)}s
                              </Text>
                            </Group>
                          </>
                        );
                      })()}
                    </Stack>
                  ) : (
                    <Text size="sm" c="dimmed" style={{ textAlign: 'center' }}>
                      Nog geen kwaliteitsgegevens beschikbaar
                    </Text>
                  )}
                </Stack>
              </Card>
            </SimpleGrid>
          </Tabs.Panel>
        </Tabs>
      </Stack>

      {/* Settings Modal */}
      <Modal opened={settingsOpened} onClose={closeSettings} title="OCR Instellingen" size="lg">
        <Stack gap="md">
          <Select
            label="OCR Engine"
            description="Kies de OCR engine voor documentverwerking"
            value={processingSettings.ocrEngine}
            onChange={(value) => setProcessingSettings(prev => ({ 
              ...prev, 
              ocrEngine: value as any || 'auto' 
            }))}
            data={[
              { value: 'auto', label: 'Automatisch (Aanbevolen)' },
              { value: 'tesseract', label: 'Tesseract OCR' },
              { value: 'ocr_space', label: 'OCR.space API' },
              { value: 'google_vision', label: 'Google Vision API' },
              { value: 'azure_cognitive', label: 'Azure Cognitive Services' }
            ]}
          />

          <Select
            label="Taal"
            description="Primaire taal voor OCR herkenning"
            value={processingSettings.language}
            onChange={(value) => setProcessingSettings(prev => ({ 
              ...prev, 
              language: value || 'nld' 
            }))}
            data={[
              { value: 'nld', label: 'Nederlands' },
              { value: 'eng', label: 'Engels' },
              { value: 'deu', label: 'Duits' },
              { value: 'fra', label: 'Frans' }
            ]}
          />

          <NumberInput
            label="Betrouwbaarheidsdrempel"
            description="Minimale betrouwbaarheid voor geaccepteerde resultaten"
            value={processingSettings.confidenceThreshold}
            onChange={(value) => setProcessingSettings(prev => ({ 
              ...prev, 
              confidenceThreshold: Number(value) || 0.7 
            }))}
            min={0.1}
            max={1.0}
            step={0.1}
            decimalScale={1}
          />

          <Stack gap="xs">
            <Text size="sm" fw={500}>Verwerkingsopties</Text>
            
            <Switch
              label="Afbeelding verbeteren"
              description="Automatische beeldverbetering voor betere OCR resultaten"
              checked={processingSettings.enhanceImage}
              onChange={(event) => setProcessingSettings(prev => ({ 
                ...prev, 
                enhanceImage: event.currentTarget.checked 
              }))}
            />

            <Switch
              label="Tabellen detecteren"
              description="Herken en extraheer tabelstructuren"
              checked={processingSettings.detectTables}
              onChange={(event) => setProcessingSettings(prev => ({ 
                ...prev, 
                detectTables: event.currentTarget.checked 
              }))}
            />

            <Switch
              label="Handtekeningen detecteren"
              description="Identificeer handtekeningen in documenten"
              checked={processingSettings.detectSignatures}
              onChange={(event) => setProcessingSettings(prev => ({ 
                ...prev, 
                detectSignatures: event.currentTarget.checked 
              }))}
            />

            <Switch
              label="Barcodes scannen"
              description="Herken en decodeer barcodes en QR-codes"
              checked={processingSettings.detectBarcodes}
              onChange={(event) => setProcessingSettings(prev => ({ 
                ...prev, 
                detectBarcodes: event.currentTarget.checked 
              }))}
            />

            <Switch
              label="Gestructureerde data extraheren"
              description="Automatische herkenning van formuliervelden"
              checked={processingSettings.extractStructuredData}
              onChange={(event) => setProcessingSettings(prev => ({ 
                ...prev, 
                extractStructuredData: event.currentTarget.checked 
              }))}
            />

            <Switch
              label="Velden valideren"
              description="Valideer geëxtraheerde gegevens tegen bekende patronen"
              checked={processingSettings.validateFields}
              onChange={(event) => setProcessingSettings(prev => ({ 
                ...prev, 
                validateFields: event.currentTarget.checked 
              }))}
            />
          </Stack>

          <Select
            label="Uitvoerformaat"
            description="Formaat voor geëxporteerde resultaten"
            value={processingSettings.outputFormat}
            onChange={(value) => setProcessingSettings(prev => ({ 
              ...prev, 
              outputFormat: value as any || 'json' 
            }))}
            data={[
              { value: 'json', label: 'JSON' },
              { value: 'xml', label: 'XML' },
              { value: 'csv', label: 'CSV' },
              { value: 'txt', label: 'Platte tekst' }
            ]}
          />

          <Group justify="flex-end">
            <Button variant="light" onClick={closeSettings}>
              Annuleren
            </Button>
            <Button onClick={closeSettings}>
              Instellingen opslaan
            </Button>
          </Group>
        </Stack>
      </Modal>

      {/* Document Preview Modal */}
      <Modal 
        opened={previewOpened} 
        onClose={closePreview} 
        title={selectedDocument?.name || 'Document Preview'}
        size="xl"
        centered
      >
        {selectedDocument && (
          <Stack gap="md">
            {selectedDocument.preview ? (
              <Image
                src={selectedDocument.preview}
                alt={selectedDocument.name}
                fit="contain"
                style={{ maxHeight: '60vh' }}
              />
            ) : (
              <Paper p="xl" style={{ textAlign: 'center', backgroundColor: 'var(--mantine-color-gray-0)' }}>
                <Stack gap="md" align="center">
                  <ThemeIcon size="xl" radius="xl" variant="light" color="gray">
                    <IconFilePdf size={30} />
                  </ThemeIcon>
                  <Text size="lg" fw={500}>PDF Preview</Text>
                  <Text size="sm" c="dimmed">
                    PDF preview wordt binnenkort ondersteund
                  </Text>
                </Stack>
              </Paper>
            )}

            <Group justify="space-between">
              <div>
                <Text size="sm" fw={500}>{selectedDocument.name}</Text>
                <Text size="xs" c="dimmed">
                  {(selectedDocument.size / 1024 / 1024).toFixed(2)} MB • {selectedDocument.type}
                </Text>
              </div>
              
              <Group gap="xs">
                <ActionIcon variant="light">
                  <IconZoomIn size={16} />
                </ActionIcon>
                <ActionIcon variant="light">
                  <IconZoomOut size={16} />
                </ActionIcon>
                <ActionIcon variant="light">
                  <IconRotate size={16} />
                </ActionIcon>
                <ActionIcon variant="light">
                  <IconDownload size={16} />
                </ActionIcon>
              </Group>
            </Group>
          </Stack>
        )}
      </Modal>

      {/* OCR Results Modal */}
      <Modal 
        opened={resultsOpened} 
        onClose={closeResults} 
        title="OCR Resultaten"
        size="xl"
        centered
      >
        {selectedDocument?.ocrResults && (
          <Tabs defaultValue="text">
            <Tabs.List>
              <Tabs.Tab value="text" leftSection={<IconFileText size={16} />}>
                Geëxtraheerde Tekst
              </Tabs.Tab>
              <Tabs.Tab value="structured" leftSection={<IconDatabase size={16} />}>
                Gestructureerde Data
              </Tabs.Tab>
              <Tabs.Tab value="quality" leftSection={<IconChartBar size={16} />}>
                Kwaliteitsmetrieken
              </Tabs.Tab>
              <Tabs.Tab value="validation" leftSection={<IconShield size={16} />}>
                Validatie
              </Tabs.Tab>
            </Tabs.List>

            <Tabs.Panel value="text" pt="md">
              <Stack gap="md">
                <Group justify="space-between">
                  <Badge variant="light" color="blue">
                    Betrouwbaarheid: {Math.round(selectedDocument.ocrResults.confidence * 100)}%
                  </Badge>
                  <Group gap="xs">
                    <ActionIcon 
                      variant="light" 
                      onClick={() => navigator.clipboard.writeText(selectedDocument.ocrResults!.extractedText)}
                    >
                      <IconCopy size={16} />
                    </ActionIcon>
                    <ActionIcon variant="light">
                      <IconDownload size={16} />
                    </ActionIcon>
                  </Group>
                </Group>
                
                <ScrollArea h={400}>
                  <Code block style={{ whiteSpace: 'pre-wrap' }}>
                    {selectedDocument.ocrResults.extractedText}
                  </Code>
                </ScrollArea>
              </Stack>
            </Tabs.Panel>

            <Tabs.Panel value="structured" pt="md">
              <Stack gap="md">
                <Text size="sm" fw={500}>
                  Document Type: {selectedDocument.ocrResults.structuredData.documentType}
                </Text>
                
                {selectedDocument.ocrResults.structuredData.fields.length > 0 ? (
                  <Table>
                    <Table.Thead>
                      <Table.Tr>
                        <Table.Th>Veld</Table.Th>
                        <Table.Th>Waarde</Table.Th>
                        <Table.Th>Type</Table.Th>
                        <Table.Th>Betrouwbaarheid</Table.Th>
                        <Table.Th>Status</Table.Th>
                      </Table.Tr>
                    </Table.Thead>
                    <Table.Tbody>
                      {selectedDocument.ocrResults.structuredData.fields.map((field, index) => (
                        <Table.Tr key={index}>
                          <Table.Td>{field.name}</Table.Td>
                          <Table.Td>{field.value}</Table.Td>
                          <Table.Td>
                            <Badge size="xs" variant="light">
                              {field.dataType}
                            </Badge>
                          </Table.Td>
                          <Table.Td>
                            <Badge 
                              size="xs" 
                              color={field.confidence > 0.8 ? 'green' : field.confidence > 0.6 ? 'orange' : 'red'}
                            >
                              {Math.round(field.confidence * 100)}%
                            </Badge>
                          </Table.Td>
                          <Table.Td>
                            {field.validated ? (
                              <IconCheck size={16} color="green" />
                            ) : (
                              <IconX size={16} color="red" />
                            )}
                          </Table.Td>
                        </Table.Tr>
                      ))}
                    </Table.Tbody>
                  </Table>
                ) : (
                  <Text size="sm" c="dimmed" style={{ textAlign: 'center' }}>
                    Geen gestructureerde velden gevonden
                  </Text>
                )}
              </Stack>
            </Tabs.Panel>

            <Tabs.Panel value="quality" pt="md">
              <SimpleGrid cols={2} spacing="md">
                <Paper p="md" withBorder>
                  <Stack gap="sm" align="center">
                    <RingProgress
                      size={120}
                      thickness={8}
                      sections={[{ 
                        value: selectedDocument.ocrResults.qualityMetrics.overallScore * 100, 
                        color: 'blue' 
                      }]}
                      label={
                        <Text size="xs" ta="center">
                          {Math.round(selectedDocument.ocrResults.qualityMetrics.overallScore * 100)}%
                        </Text>
                      }
                    />
                    <Text size="sm" fw={500}>Algemene Kwaliteit</Text>
                  </Stack>
                </Paper>

                <Stack gap="sm">
                  <Group justify="space-between">
                    <Text size="sm">Teksthelderheid</Text>
                    <Badge variant="light">
                      {Math.round(selectedDocument.ocrResults.qualityMetrics.textClarity * 100)}%
                    </Badge>
                  </Group>
                  <Progress 
                    value={selectedDocument.ocrResults.qualityMetrics.textClarity * 100} 
                    size="sm" 
                  />

                  <Group justify="space-between">
                    <Text size="sm">Beeldkwaliteit</Text>
                    <Badge variant="light">
                      {Math.round(selectedDocument.ocrResults.qualityMetrics.imageQuality * 100)}%
                    </Badge>
                  </Group>
                  <Progress 
                    value={selectedDocument.ocrResults.qualityMetrics.imageQuality * 100} 
                    size="sm" 
                  />

                  <Group justify="space-between">
                    <Text size="sm">Contrast</Text>
                    <Badge variant="light">
                      {Math.round(selectedDocument.ocrResults.qualityMetrics.contrast * 100)}%
                    </Badge>
                  </Group>
                  <Progress 
                    value={selectedDocument.ocrResults.qualityMetrics.contrast * 100} 
                    size="sm" 
                  />
                </Stack>
              </SimpleGrid>

              {selectedDocument.ocrResults.qualityMetrics.recommendations.length > 0 && (
                <Stack gap="xs" mt="md">
                  <Text size="sm" fw={500}>Aanbevelingen:</Text>
                  <List size="sm">
                    {selectedDocument.ocrResults.qualityMetrics.recommendations.map((rec, index) => (
                      <List.Item key={index}>{rec}</List.Item>
                    ))}
                  </List>
                </Stack>
              )}
            </Tabs.Panel>

            <Tabs.Panel value="validation" pt="md">
              <Stack gap="md">
                <Group justify="space-between">
                  <Badge 
                    size="lg" 
                    color={selectedDocument.ocrResults.validationResults.isValid ? 'green' : 'red'}
                    leftSection={selectedDocument.ocrResults.validationResults.isValid ? 
                      <IconCheck size={16} /> : <IconX size={16} />}
                  >
                    {selectedDocument.ocrResults.validationResults.isValid ? 'Geldig' : 'Ongeldig'}
                  </Badge>
                  <Badge variant="light">
                    Score: {Math.round(selectedDocument.ocrResults.validationResults.validationScore * 100)}%
                  </Badge>
                </Group>

                {selectedDocument.ocrResults.validationResults.complianceChecks.length > 0 && (
                  <Stack gap="sm">
                    <Text size="sm" fw={500}>Compliance Controles:</Text>
                    {selectedDocument.ocrResults.validationResults.complianceChecks.map((check, index) => (
                      <Alert
                        key={index}
                        icon={check.passed ? <IconCheck size={16} /> : <IconX size={16} />}
                        color={check.passed ? 'green' : 'red'}
                        title={check.rule}
                      >
                        <Text size="sm">{check.description}</Text>
                        <Text size="xs" c="dimmed" mt="xs">
                          Vereiste: {check.requirement}
                        </Text>
                      </Alert>
                    ))}
                  </Stack>
                )}

                {selectedDocument.ocrResults.validationResults.suggestions.length > 0 && (
                  <Stack gap="xs">
                    <Text size="sm" fw={500}>Suggesties:</Text>
                    <List size="sm">
                      {selectedDocument.ocrResults.validationResults.suggestions.map((suggestion, index) => (
                        <List.Item key={index}>{suggestion}</List.Item>
                      ))}
                    </List>
                  </Stack>
                )}
              </Stack>
            </Tabs.Panel>
          </Tabs>
        )}
      </Modal>
    </Container>
  );
};

export default DocumentOCRProcessor;


